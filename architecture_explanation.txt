ASP.NET CORE ARCHITECTURE: BINDING, VALIDATION, AND ROUTING (CHAPTER 5)

================================================================================
1. ROUTING IN ASP.NET CORE WEB API
================================================================================

Overview:
Routing is the infrastructure responsible for matching incoming HTTP requests to specific resources or Action Methods.

Middleware Configuration:
- UseRouting(): Enables the routing system within the application pipeline.
- UseEndpoints(): Maps the matched URL to the actual resource, such as Action methods.

Routing Types:
- Attribute Routing: The preferred way to define routes directly on Controller or Action levels using [Route] attributes.
- Conventional Routing: Defined centrally, typically in Program.cs.

Advanced Routing:
- Dynamic Parameters: Uses curly braces {id} to capture variable values from the URL.
- Multiple Route Templates: A single resource can be mapped to multiple different URLs.

Key Components:
- [Route], [HttpGet], [HttpPost]
- UseRouting() / UseEndpoints()
- EndpointRoutingMiddleware


================================================================================
2. MODEL BINDING MECHANISM
================================================================================

Definition:
The process where ASP.NET Core extracts data from HTTP Requests and provides it as arguments to Action Methods.

Data Sources:
The framework scans Form data, Route variables, and Query strings by default.

Model Binders:
- Primitive Model Binder: Handles simple types like int, string, bool, GUID, and DateTime (typically from URI sources).
- Complex Model Binder: Handles objects or classes, primarily extracting data from the Request Body (JSON).

Binding Source Attributes:
- [FromBody]: Extracts data from the Request body.
- [FromForm]: Extracts data from encoded form data.
- [FromHeader]: Extracts data from HTTP headers.
- [FromQuery]: Extracts data from URL query strings.
- [FromRoute]: Extracts data from route parameters.
- [FromServices]: Injects data from the DI container.

Default Values:
Fallback values if data is missing: 0 for numeric types, "" for strings, 01-01-0001 for DateTime.


================================================================================
3. MODEL VALIDATION PIPELINE
================================================================================

Definition:
Ensures submitted data is user-friendly, secure, and complies with business rules before processing.

Validation Attributes (Data Annotations):
- [Required]: Ensures the field is not null.
- [StringLength] / [MaxLength]: Limits text length.
- [Range]: Constrains numeric values.
- [EmailAddress] / [Url] / [Phone]: Validates specific formats.
- [RegularExpression]: Matches data against a pattern.

ModelState Logic:
- Represents errors from both binding failures and validation attribute violations.
- ModelState.IsValid: A boolean check used in the action to verify overall validation status.

Validation Scopes:
- Server-Side: Mandatory validation for security and data integrity.
- Client-Side: Uses JavaScript/jQuery (Unobtrusive) to provide fast feedback and avoid redundant server round-trips.


================================================================================
4. ARCHITECTURAL PATTERNS
================================================================================

- Repository Pattern: Decouples data access from business logic via an abstraction layer.
- DTO (Data Transfer Object): Manipulates and returns data without exposing sensitive domain entities.
- AutoMapper: Simplifies property mapping between Entities and DTOs.

================================================================================
SUMMARY
================================================================================
The request lifecycle follows a critical sequence: ROUTING (Match the destination) -> BINDING (Populate the data) -> VALIDATION (Verify integrity). Only after these layers succeed does the core Logic and Repository handle the business requirements.
